name: Build and Publish Docker Image

on:
  push:
    branches: [ main ]
  schedule:
    - cron: "0 4 * * 1"
  workflow_dispatch:

jobs:
  resolve-base-digests:
    runs-on: ubuntu-latest
    outputs:
      base_digests: ${{ steps.resolve.outputs.base_digests }}
      resolution_failed: ${{ steps.resolve.outputs.resolution_failed }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Resolve base image digests
        id: resolve
        env:
          DOCKERFILE_PATH: Dockerfile
        run: |
          set -euo pipefail

          refs_file="$(mktemp)"
          digests_file="$(mktemp)"

          python3 - "$DOCKERFILE_PATH" <<'PY' > "$refs_file"
          import os
          import pathlib
          import re
          import sys

          dockerfile_path = pathlib.Path(sys.argv[1])
          if not dockerfile_path.exists():
              raise SystemExit(f"Dockerfile not found: {dockerfile_path}")

          arg_defaults = {}
          in_global_scope = True
          arg_re = re.compile(r"^\s*ARG\s+([A-Za-z_][A-Za-z0-9_]*)(?:=(.*))?\s*$", re.IGNORECASE)
          from_re = re.compile(r"^\s*FROM\s+", re.IGNORECASE)
          var_re = re.compile(r"\$(?:\{([A-Za-z_][A-Za-z0-9_]*)\}|([A-Za-z_][A-Za-z0-9_]*))")

          def expand(value: str) -> str:
              def repl(match: re.Match[str]) -> str:
                  key = match.group(1) or match.group(2)
                  if key in os.environ:
                      return os.environ[key]
                  if key in arg_defaults:
                      return arg_defaults[key]
                  return match.group(0)
              return var_re.sub(repl, value)

          refs = []
          for raw_line in dockerfile_path.read_text(encoding="utf-8").splitlines():
              line = raw_line.strip()
              if not line or line.startswith("#"):
                  continue

              arg_match = arg_re.match(line)
              if arg_match and in_global_scope:
                  key, val = arg_match.group(1), arg_match.group(2)
                  arg_defaults[key] = "" if val is None else val
                  continue

              if from_re.match(line):
                  in_global_scope = False
                  tokens = line.split()
                  idx = 1
                  while idx < len(tokens) and tokens[idx].startswith("--"):
                      idx += 1
                  if idx < len(tokens):
                      refs.append(expand(tokens[idx]))

          for ref in refs:
              print(ref)
          PY

          if [ ! -s "$refs_file" ]; then
            echo "No FROM references found in $DOCKERFILE_PATH"
            {
              echo "resolution_failed=true"
              echo "base_digests="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          failed=0
          while IFS= read -r ref; do
            [ -z "$ref" ] && continue

            inspect_output="$(docker buildx imagetools inspect "$ref" 2>/dev/null)" || {
              echo "Unable to inspect base image: $ref"
              failed=1
              continue
            }

            name="$(printf '%s\n' "$inspect_output" | awk -F': +' '/^Name:/ {print $2; exit}')"
            digest="$(printf '%s\n' "$inspect_output" | awk -F': +' '/^Digest:/ {print $2; exit}')"

            if [ -z "$name" ] || [ -z "$digest" ]; then
              echo "Missing name or digest for base image: $ref"
              failed=1
              continue
            fi

            printf '%s@%s\n' "$name" "$digest" >> "$digests_file"
          done < "$refs_file"

          if [ "$failed" -eq 1 ]; then
            {
              echo "resolution_failed=true"
              echo "base_digests="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          base_digests="$(sort -u "$digests_file" | paste -sd';' -)"

          {
            echo "resolution_failed=false"
            echo "base_digests=$base_digests"
          } >> "$GITHUB_OUTPUT"

  decide-build:
    runs-on: ubuntu-latest
    needs: resolve-base-digests
    outputs:
      should_build: ${{ steps.decision.outputs.should_build }}
      reason: ${{ steps.decision.outputs.reason }}
      image_name: ${{ steps.image.outputs.image_name }}
    steps:
      - name: Resolve image name
        id: image
        run: |
          set -euo pipefail

          IMAGE_NAME_INPUT="${{ vars.IMAGE_NAME }}"
          if [ -z "$IMAGE_NAME_INPUT" ]; then
            IMAGE_NAME_INPUT="${GITHUB_REPOSITORY##*/}"
          fi

          IMAGE_NAME="$(printf '%s' "$IMAGE_NAME_INPUT" | tr '[:upper:]' '[:lower:]')"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Decide whether build is required
        id: decision
        env:
          EVENT_NAME: ${{ github.event_name }}
          IMAGE_REPOSITORY: ${{ secrets.DOCKERHUB_USERNAME }}/${{ steps.image.outputs.image_name }}
          CURRENT_BASE_DIGESTS: ${{ needs.resolve-base-digests.outputs.base_digests }}
          RESOLUTION_FAILED: ${{ needs.resolve-base-digests.outputs.resolution_failed }}
        run: |
          set -euo pipefail

          if [ "$EVENT_NAME" != "schedule" ]; then
            {
              echo "should_build=true"
              echo "reason=event-triggered-build"
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "$RESOLUTION_FAILED" = "true" ]; then
            {
              echo "should_build=true"
              echo "reason=base-digest-resolution-failed"
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ -z "$CURRENT_BASE_DIGESTS" ]; then
            {
              echo "should_build=true"
              echo "reason=base-digests-empty"
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if ! docker pull "$IMAGE_REPOSITORY:latest" >/dev/null 2>&1; then
            {
              echo "should_build=true"
              echo "reason=latest-not-found"
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          previous_base_digests="$(docker image inspect "$IMAGE_REPOSITORY:latest" --format '{{ index .Config.Labels "org.opencontainers.image.base-digests" }}' || true)"

          if [ -z "$previous_base_digests" ]; then
            {
              echo "should_build=true"
              echo "reason=latest-missing-base-digests-label"
            } >> "$GITHUB_OUTPUT"
          elif [ "$previous_base_digests" != "$CURRENT_BASE_DIGESTS" ]; then
            {
              echo "should_build=true"
              echo "reason=base-images-changed"
            } >> "$GITHUB_OUTPUT"
          else
            {
              echo "should_build=false"
              echo "reason=base-images-unchanged"
            } >> "$GITHUB_OUTPUT"
          fi

  docker:
    runs-on: ubuntu-latest
    needs:
      - resolve-base-digests
      - decide-build
    if: ${{ needs.decide-build.outputs.should_build == 'true' }}
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKERHUB_USERNAME }}/${{ needs.decide-build.outputs.image_name }}
          tags: |
            type=raw,value=latest
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          push: true
          pull: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: |
            ${{ steps.meta.outputs.labels }}
            org.opencontainers.image.base-digests=${{ needs.resolve-base-digests.outputs.base_digests }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Update Docker Hub description
        uses: peter-evans/dockerhub-description@v4
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          repository: ${{ secrets.DOCKERHUB_USERNAME }}/${{ needs.decide-build.outputs.image_name }}
          short-description: ${{ github.event.repository.description }}
          readme-filepath: ./README.md

  skip-build:
    runs-on: ubuntu-latest
    needs: decide-build
    if: ${{ needs.decide-build.outputs.should_build != 'true' }}
    steps:
      - name: Log skip reason
        run: |
          echo "Skipping Docker build: ${{ needs.decide-build.outputs.reason }}"
